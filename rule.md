# 前后端协作流程

进入开发阶段之前，先制定接口规范，并生成 mock 数据以供前后端无障碍同步开发。
接口规范制定好之后，不允许私自更改接口，如发现不合理的地方，<b>必须通过前后端相关人员一致同意方可修改</b>。
后端验收标准按照接口规范进行验收。

# 接口规范

## 接口分类

| 分类     | 实例                        |
| -------- | --------------------------- |
| 公共接口 | 获取系统配置/获取页面配置等 |
| 业务接口 | 用户调岗等                  |
| 通用接口 | key/value                   |

## 可选数据默认值规范

| 类型   | 默认值    |
| ------ | --------- |
| array  | [] 空数组 |
| object | {} 空结构 |

### 接口协商要点

- 接口必须返回统一的数据结构, 参考[后端接口通用规范中接口返回的数据结构](#接口返回数据通用结构)
- 接口查询不到数据时, 即空数据的情况下返回给前端怎样的数据
  - 建议返回非 `null` 的对应数据类型初始值, 例如对象类型的返回空对象(`{}`), 数组类型的返回空数组(`[]`), 其他原始数据类型(`string`/`number`/`boolean`...)也使用对应的默认值
  - 这样可以减少前端很多琐碎的非空判断, 直接使用接口中的数据
  - 例如: `result.fieldName`
  - 如果 `result` 为 `null`, 可想而知会报错 `Uncaught TypeError: Cannot read property 'fieldName' of null`
- 调用接口业务失败的常用错误码, 例如未授权时调用需要授权的接口返回 `"code": 403`
- 接口需要登录时如何处理, 特别是同时涉及到 Web 端/微信端/App 端, 需要前端针对运行环境判断如何跳转到登录页面
- 返回数据中图片 URL 是完整的还是部分的
  - `http://a.res.com/path/to/img.png` 这就是完整的, 前端直接使用这个 URL
  - `/path/to/img.png` 这就是部分的, 一般省略域名部分, 前端需要自己拼接后才能使用 `'http://a.res.com' + '/path/to/img.png'`
- 返回数据中页面跳转的 URL 是给完整的还是部分的
  - 内部页面返回部分的, 或者只给 ID, 由前端自己拼接, 例如只给出商品 ID, 让前端自己拼接商品详情页的 URL
  - 外部页面返回完整的, 例如广告位要跳转去谷歌
- 返回数据中日期的格式, 是使用时间戳还是格式化好的文字
  - 对于需要前端再次处理的日期值(例如根据日期计算倒计时), 可以使用时间戳(简单暴力), 例如: `1458885313711`, 或者参考 [Date.prototype.toJSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toJSON) 提供 ISO 标准格式(例如需要考虑时区时)
  - 对于纯展示用的日期值, 推荐返回为格式化好的文字, 例如: `9102年2月19日`
- **对于大数字(例如 Java 的 long 类型), 返回给前端时需要设置为字符串类型, 否则 `JavaScript` 会发生溢出, 造成得到的数值错误**
  - 例如: 返回 JSON 数据 `{"id": 362909601374617692}` 前端拿到的值却是: `362909601374617660`
- 分页参数和分页信息
  - 如何限制只返回 N 条数据(limit 参数)
  - 如何控制每页的数据条数(pageSize 参数)
  - 如何加载某一页的数据(page 参数)
    - 第一页是从 0 开始还是从 1 开始
  - 如何避免无限滚动加载可能出现的重复数据(采用 lastId 分页方式, 来避免传统分页方式的弊端)
    - 假设数据是按照新增时间倒序排列的
    - 首先加载 2 页的数据
    - 等了很久
    - 期间新增了很多数据
    - 再获取第 3 页数据
    - 此时就可能出现重复数据的情况, 因为新增的数据都排在最前面, 后面会接着已经加载过数据
  - 分页信息包含什么(total, page, pageSize)
  - 分页信息何时表明已经是最后一页了
    - 请求某页数据时返回的数据条数 < pageSize
    - 请求某页数据时返回的数据条数 = 0
    - 如果碰巧最后一页有 pageSize 条数据, 前端无法通过数据条数来判断已经处于最后一页了

### 接口定义

<a href="https://app.graphqleditor.com" target="_block">
<img src="https://images.gitee.com/uploads/images/2019/0812/104602_af271e5d_888642.png" width="217px" height="40px">
</a>

### 接口协作

由于接口规范的定义和接口的实际实现是分开的两个部分, 而且涉及到多人协作, 因此在开发过程中可能出现接口规范与实现不同步, 最终造成实际的接口不符合规范的定义, 接口规范就会慢慢失去存在的意义.

为了尽量避免这种问题, 后端在实现接口的过程中应该确保与接口规范保持一致, 一旦出现分歧, 必须同步修改接口规范, 尽可能保持沟通.

### 接口名称规范

遵循 **数据范围+数据用途/数据操作** 定义接口名称

| 数据用途/操作          | 接口名称后缀 | 返回值       |
| :--------------------- | :----------- | :----------- |
| 列表、表格、下拉框选项 | list         | 数组         |
| 树                     | tree         | 数组         |
| 新增、编辑             | edit         | 当前操作对象 |
| 删除                   | delete       | 当前操作对象 |
| 详情                   | detail       | 当前操作对象 |
| 更新                   | update       | 当前操作对象 |
| 其他                   | 按业务定义   |

例如

- 需求为 **部门管理** ，获取部门下岗位的 table 数据接口名为 **postList**，查看某一个岗位的详情数据 **postDetail** ，新增/编辑某一个岗位数据 **postEdit**，删除岗位 **postDelete**
- 全局接口以 **global** 作为前缀

### 接口返回数据通用结构

| **字段名** | **字段说明**                                                                                                                           |
| :--------- | :------------------------------------------------------------------------------------------------------------------------------------- |
| data       | **业务数据**<br>必须是任意 JSON 数据类型(number/string/boolean/object/array).                                                          |
| code       | **状态码**<br>详见下方错误码说明[错误码规范](#错误码规范), 此时可以省略 `data` 字段, 并视情况输出 `message` 字段作为补充信息</li></ul> |
| message    | **状态信息**<br>必须是任意 JSON 数据类型. 作为接口处理失败时, **给予用户的友好的提示信息**, 即所有给用户的提示信息都统一由后端来处理.  |

## 错误码规范

> `code` 字段该如何取值

采用前后端分离后, 前端负责调用后端的接口来展现界面, 如果有界面显示异常, 需要有快速方便的手段来排查线上错误和定位出职责范围

综合了经验总结和行业实践, 最简单有效的手段是制定出一套统一的错误码规范, 协助多方人员来排查出接口的错误

例如

- 用户发现错误, 可以截错误码的图, 就能够提供有效的信息帮助开发人员排查错误
- 测试人员发现错误, 可以通过错误码, 快速定位是前端的问题还是后端接口的问题

因此我们确定提示信息规范为: 当后端接口调用出错时, 接口提供一个用户可以理解的错误提示, 前端展示给用户错误提示和错误码, 给予用户反馈

对于错误码的规范, 参考行业实践, 大致有两种方案

- 做显性的类型区分, 快速定位错误的类别, 例如通过字母划分类型: `A101`, `B131`
  - [Standard ISO Response Codes](http://www.nexion.co.za/docs/merchant-access/user-manual/17.%20Standard%20ISO%20Response%20codes.pdf)
- 固定位数, 设定区间(例如手机号码, 身份证号码)来划分不同的错误类型
  - [HTTP Status Code Definitions](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html "Most API services follow the HTTP error code system RFC2616 with ranges of error codes for different types of error")
  - [System Error Codes](https://docs.microsoft.com/en-us/windows/desktop/Debug/system-error-codes)

具体实践如下

- **错误码固定长度**, 以区间来划分错误类型(例如 HTTP 的状态码)

  例如: 10404 表示 HTTP 请求 404 错误, 20000 表示 API 调用失败, 30000 代表业务错误, 31000 表示业务 A 错误, 32000 表示业务 B 错误

- **错误码可不固定长度**, 以首字母来划分错误类型, 可扩展性更好, 但实际运作还是需要划分区间

  例如: H404 表示 HTTP 请求 404 错误, A100 表示 API 调用失败, B100 表示业务 A 错误, B200 表示业务 B 错误

关于错误分类的原则, 我们可以根据发送请求的最终状态来划分

- 发送失败(即请求根本就没有发送出去)
- 发送成功
  - HTTP 异常状态(例如 404/500...)
  - HTTP 正常状态(例如 200)
    - 接口调用成功
    - 接口调用失败(业务错误, 即接口规范中 code 非 200 的情况)

# 最终规范

> 错误码可不固定长度, 整体格式为: `前缀(字母)+错误等级+子系统编号+业务编码`, `前缀(字母)`作为错误类型, 可扩展性更好, `业务编码`建议划分区间来细分错误

| 码位 | 作用                                        |
| ---- | ------------------------------------------- |
| 1    | [H: Http B: Backend C: Client](#错误码前缀) |
| 2    | [错误等级](#错误等级)                       |
| 3    | [子系统编号](#子系统编号)                   |
| 4    | [子系统编号](#子系统编号)                   |
| 5    | [子系统编号](#子系统编号)                   |
| 6    | [业务编码](#业务编码)                       |
| 7    | [业务编码](#业务编码)                       |
| 8    | [业务编码](#业务编码)                       |

## 错误码前缀

- `H` for **HTTP**, HTTP 异常状态的错误, 例如 `H404` 表示 HTTP 请求 404 错误
- `B` for **backend or business**, 接口调用失败的错误, 例如 `B100` 业务 A 错误, `B200` 业务 B 错误
- `C` for **Client**: 客户端错误, 例如 `C100` 表示解析 JSON 失败

## 错误等级

> 0-10 依次增加，7 以上需要通知相关人员。H 开头通知运维，B 开头通知后端，C 通知前端

| 等级 | 说明  | 操作         |
| ---- | ----- | ------------ |
| 0-3  | log   | 无           |
| 4-6  | info  | 无           |
| 7-9  | error | 通知相关人员 |

## 子系统编号

> 3-5 位

| 子系统 | 编码             |
| ------ | ---------------- |
| 001    | 基础信息管理系统 |

## 业务编码

> 6-8 位,如 404 表示请求资源不存在

| 编码    | 说明           |
| ------- | -------------- |
| 200-300 | 成功           |
| 403     | 登陆失效       |
| 404     | 访问资源不存在 |

### 统一错误提示

- 错误日志
  - 接口调用出错(`${错误码}`) `${HTTP 方法}` `${HTTP URL}` `${请求参数}` `${请求选项}` `${请求返回结果}`
  - 例如: `接口调用出错(H404) GET https://domain.com {foo: bar} {option1: 'test'} {status: 404}`
- 给用户的提示消息(参考自 QQ 的错误提示消息)

  - 提示消息(错误码: xxx)

    ![weapp-error-tip](https://images.gitee.com/uploads/images/2019/0813/102756_8b8bcb09_888642.png) ![weibo-error-tip](https://user-images.githubusercontent.com/167221/54168905-a2076200-44ab-11e9-8607-48eb9a08156b.PNG) ![qq-error-tip](https://images.gitee.com/uploads/images/2019/0813/102756_8032ab8c_888642.png)

  - 提示消息和错误码之间用换行隔开
  - 错误码整块内容建议弱化使用灰色字
  - 例如
    ![mobile-error-code-message](https://user-images.githubusercontent.com/167221/50005112-239e3f80-ffe4-11e8-9996-2affc01b8b31.png)
    ![pc-error-code-message](https://images.gitee.com/uploads/images/2019/0813/102801_16e86ec3_888642.png)

规范实现: [weapp-backend-api](https://github.com/ufologist/weapp-backend-api)

## 注意

- [Version](https://developer.github.com/v3/media/#request-specific-version "Accept: application/vnd.github.v3+json")
- 跨域
  - [CORS](https://developer.github.com/v3/#cross-origin-resource-sharing "Cross Origin Resource Sharing")
  - [JSONP](https://developer.github.com/v3/#json-p-callbacks)
- [避免中文乱码](http://blog.csdn.net/chaijunkun/article/details/8257209 "将中文等非 ASCII 字符转义为 \uFFFF 这样的 unicode 形式 | non-ASCII characters to be escaped as \uFFFF")
